# Issue #29: RedisConnection Wrapper設計案

## 問題の概要（視覚的理解）

### 現状の問題を図で理解する

```
現在のアーキテクチャ:

  ┌─────────────────────────────────────┐
  │   RedisSessionHandler               │
  │                                     │
  │   ┌───────────────────────┐         │
  │   │ Session Read/Write    │         │
  │   │   ↓                   │         │
  │   │ Hook Pipeline         │         │
  │   │   ↓                   │         │
  │   │ Redis A (Primary)     │  ✓ OK  │
  │   └───────────────────────┘         │
  │                                     │
  │   ┌───────────────────────┐         │
  │   │ ReadTimestampHook     │         │
  │   │   ↓                   │         │
  │   │ Redis A (Primary)     │  ✗ NG  │ ← Hook内部の操作は
  │   │     直接アクセス       │         │    他のHookを経由しない！
  │   └───────────────────────┘         │
  └─────────────────────────────────────┘
```

### 問題シナリオ: プライマリRedisダウン時

```
┌──────────────────────────────────────────────────┐
│ シナリオ: Redis Aがダウン                        │
└──────────────────────────────────────────────────┘

構成:
  [Redis A] ✗ ダウン
  [Redis B] ✓ 正常 (フォールバック用)

動作:
  1. セッション読み込み:
     RedisSessionHandler → FallbackReadHook
     → Redis A (失敗) → Redis B (成功) ✓

  2. タイムスタンプ記録:
     ReadTimestampHook → Redis A (失敗) ✗

     ┌─────────────────────────────────┐
     │ 問題: タイムスタンプが          │
     │ フォールバックされない！        │
     └─────────────────────────────────┘
```

### 根本原因の視覚化

```
     セッションデータの流れ        vs    Hook内部のRedis操作

┌─────────────────────┐         ┌─────────────────────┐
│  RedisSessionHandler│         │  ReadTimestampHook  │
└──────────┬──────────┘         └──────────┬──────────┘
           │                               │
           ↓                               ↓
    ┌─────────────┐                  ┌─────────────┐
    │ Hook Pipeline│                  │  直接Redis  │
    └──────┬──────┘                  │   アクセス  │
           │                          └──────┬──────┘
           ↓                                 │
    ┌─────────────┐                         │
    │ Fallback?   │                         ↓
    │ MultiWrite? │              ┌──────────────────┐
    └──────┬──────┘              │ Redis A のみ     │
           │                     │                  │
           ↓                     │ Hookの恩恵を     │
    ┌─────────────┐              │ 受けられない！   │
    │  Redis群    │              └──────────────────┘
    └─────────────┘

    ✓ フォールバック OK            ✗ フォールバック NG
    ✓ ダブルライト OK              ✗ ダブルライト NG
```

## 設計案の比較

### 3つのアプローチ

```
┌──────────────────────────────────────────────────────────────┐
│ Option 1: HookAware      │ Hook内でもHookを実行              │
│ Option 2: Pool           │ 複数Redisを一元管理               │
│ Option 3: Composite ✓    │ Redisを透過的にラップ (推奨)     │
└──────────────────────────────────────────────────────────────┘
```

---

### オプション1: HookAwareRedisConnection

```
┌──────────────────────────────────┐
│  HookAwareRedisConnection        │
│  ┌────────────────────────┐      │
│  │ Hook Pipeline          │      │
│  │   ↓                    │      │
│  │ Inner RedisConnection  │      │
│  │   ↓                    │      │
│  │ Hook Pipeline (再度)   │ ← 循環！
│  └────────────────────────┘      │
└──────────────────────────────────┘

概念: Redis操作のたびにHookを実行
```

**評価:**
- ✗ 循環依存リスク（HookがHookを呼ぶ）
- ✗ 無限ループの危険性
- ✗ デバッグが困難

**結論:** ❌ 推奨しない

---

### オプション2: RedisConnectionPool

```
┌──────────────────────────────────┐
│  RedisConnectionPool             │
│  ┌────────────────────────┐      │
│  │ Policy: FAILOVER       │      │
│  │         DOUBLE_WRITE   │      │
│  └────────┬───────────────┘      │
│           ↓                      │
│     ┌─────┴─────┐                │
│     ↓           ↓                │
│ [Redis A]   [Redis B]            │
└──────────────────────────────────┘

概念: ポリシーベースでRedis操作を振り分け
```

**評価:**
- △ 既存のHook（FallbackReadHook等）と機能重複
- △ アーキテクチャの大幅変更が必要
- ○ 複数Redis管理は一元化できる

**結論:** △ 可能だが、既存設計と相反

---

### オプション3: CompositeRedisConnection (推奨)

```
┌───────────────────────────────────────────────────────────┐
│  RedisConnectionInterface (共通インターフェース)          │
└───────────────┬───────────────────────────────────────────┘
                │
        ┌───────┴─────────┐
        ↓                 ↓
┌───────────────┐   ┌─────────────────────────────┐
│ RedisConnection│   │ CompositeRedisConnection    │
│ (既存)        │   │ (新規・複数Redisをラップ)    │
└───────────────┘   └────────┬────────────────────┘
                             │
                    ┌────────┴────────┐
                    ↓                 ↓
            ┌───────────────┐  ┌──────────────┐
            │ Failover版    │  │ MultiWrite版 │
            └───────────────┘  └──────────────┘

概念: 複数RedisをCompositeパターンで透過的にラップ
```

#### Failover版の動作イメージ

```
FailoverRedisConnection
├─ Redis A (Primary)
├─ Redis B (Fallback 1)
└─ Redis C (Fallback 2)

get(key) の動作:
┌────────────────┐
│ get(key) 呼出  │
└────────┬───────┘
         ↓
    ┌─────────┐
    │ Redis A │ → 失敗 ✗
    └─────────┘
         ↓
    ┌─────────┐
    │ Redis B │ → 成功！✓ (返却)
    └─────────┘

set(key, val) の動作:
┌────────────────┐
│ set(key) 呼出  │
└────────┬───────┘
         ↓
    ┌─────────┐
    │ Redis A │ → 失敗 ✗
    └─────────┘
         ↓
    ┌─────────┐
    │ Redis B │ → 成功！✓ (終了)
    └─────────┘
```

#### MultiWrite版の動作イメージ

```
MultiWriteRedisConnection
├─ Redis A (Primary)
├─ Redis B (Replica 1)
└─ Redis C (Replica 2)

get(key) の動作:
┌────────────────┐
│ get(key) 呼出  │
└────────┬───────┘
         ↓
    ┌─────────┐
    │ Redis A │ ← Primaryからのみ読む
    └─────────┘

set(key, val) の動作:
┌────────────────┐
│ set(key) 呼出  │
└────────┬───────┘
         │
    ┌────┼─────┐
    ↓    ↓     ↓
┌───────┐┌───────┐┌───────┐
│Redis A││Redis B││Redis C│ ← 全てに書き込み
└───────┘└───────┘└───────┘
```

#### 使用例（概念）

```
Before (問題あり):
  ReadTimestampHook
    → Redis A のみ (フォールバックしない)

After (解決):
  ReadTimestampHook
    → FailoverRedisConnection
       ├─ Redis A (失敗)
       └─ Redis B (成功) ✓
```

**評価:**

✅ **既存コードとの互換性**
- インターフェースを実装するため、Hookのコード変更不要
- `ReadTimestampHook`などはそのまま使える

✅ **循環依存なし**
- Composite自体はHookを意識しない
- 安全な設計

✅ **柔軟性**
- Failover、MultiWrite、カスタム戦略を自由に選択
- Composite同士のネストも可能

△ **若干の複雑性増加**
- 新しいインターフェースと抽象クラスの追加
- ただし、既存コードへの影響は最小限

**結論:** ✅ **推奨** （最もバランスが良い）

---

## 推奨設計の詳細

### 全体アーキテクチャ

```
┌─────────────────────────────────────────────────────────────┐
│  アプリケーション層                                          │
│  ┌──────────────────────────────────────────────┐           │
│  │  RedisSessionHandler                         │           │
│  │  ┌────────────────────────────────┐          │           │
│  │  │  ReadTimestampHook             │          │           │
│  │  │  DoubleWriteHook               │          │           │
│  │  │  その他のHook...               │          │           │
│  │  └────────────────────────────────┘          │           │
│  └────────────────┬─────────────────────────────┘           │
│                   │ RedisConnectionInterface                │
│                   │ (共通インターフェース)                  │
└───────────────────┼─────────────────────────────────────────┘
                    ↓
┌───────────────────┴─────────────────────────────────────────┐
│  接続管理層                                                  │
│  ┌──────────────┐        ┌───────────────────────┐          │
│  │ RedisConn    │        │ CompositeRedisConn    │          │
│  │ (単一Redis)  │        │ (複数Redisラップ)     │          │
│  └──────────────┘        └───────┬───────────────┘          │
│                                  │                          │
│                         ┌────────┼────────┐                 │
│                         ↓        ↓        ↓                 │
│                  ┌──────────┐┌──────────┐┌──────────┐      │
│                  │ Failover ││MultiWrite││ Custom.. │      │
│                  └──────────┘└──────────┘└──────────┘      │
└───────────────────┬────────────┬───────────┬────────────────┘
                    ↓            ↓           ↓
┌───────────────────┴────────────┴───────────┴────────────────┐
│  Redis/ValKey 実体                                           │
│  [Redis A]    [Redis B]    [Redis C]    [Redis D]...        │
└──────────────────────────────────────────────────────────────┘
```

### Before / After の視覚的比較

#### Before (現状の問題)

```
┌─────────────────────────────────────────────────┐
│ RedisSessionHandler                             │
│  ↓                                              │
│ [Primary Redis]  ← セッションデータ            │
│                                                 │
│ ReadTimestampHook                               │
│  ↓                                              │
│ [Primary Redis]  ← タイムスタンプ (固定)       │
│                                                 │
│ FallbackReadHook (Primaryダウン時のみ)         │
│  ↓                                              │
│ [Fallback Redis] ← セッションデータのみ        │
└─────────────────────────────────────────────────┘

問題: タイムスタンプは常にPrimaryにしか書けない
      → Primaryダウン時、タイムスタンプ記録失敗
```

#### After (Composite使用)

```
┌─────────────────────────────────────────────────┐
│ RedisSessionHandler                             │
│  ↓                                              │
│ FailoverRedisConnection                         │
│  ├─ [Primary Redis]                             │
│  └─ [Fallback Redis] ← 自動フォールバック       │
│                                                 │
│ ReadTimestampHook                               │
│  ↓                                              │
│ FailoverRedisConnection (同じ戦略)              │
│  ├─ [Primary Redis]                             │
│  └─ [Fallback Redis] ← 自動フォールバック       │
└─────────────────────────────────────────────────┘

解決: セッションもタイムスタンプも同じフォールバック戦略
      → Primaryダウン時、全てFallbackに自動切替
```

### 段階的な移行パス

```
Phase 1: インターフェース導入
┌──────────────────────────────┐
│ RedisConnectionInterface     │ ← 新規追加
│ RedisConnection implements   │ ← 既存クラスに追加
└──────────────────────────────┘
         ↓
   ✓ 既存機能テスト

Phase 2: Composite基底クラス
┌──────────────────────────────┐
│ CompositeRedisConnection     │ ← 抽象クラス追加
│ (connect/disconnect等の共通) │
└──────────────────────────────┘
         ↓
   ✓ ユニットテスト作成

Phase 3: 具象Composite実装
┌──────────────────────────────┐
│ FailoverRedisConnection      │ ← 具象クラス実装
│ MultiWriteRedisConnection    │
└──────────────────────────────┘
         ↓
   ✓ 統合テスト・動作確認

Phase 4: ドキュメント整備
┌──────────────────────────────┐
│ 使用例・サンプルコード       │
│ CLAUDE.mdに設計パターン追記  │
└──────────────────────────────┘
         ↓
   ✓ レビュー・フィードバック

Phase 5: 既存Hookの扱い（オプション）
┌──────────────────────────────┐
│ FallbackReadHook → 非推奨？  │ ← Compositeで代替可能
│ DoubleWriteHook  → 非推奨？  │    (後方互換性は維持)
└──────────────────────────────┘
```

## 代替案の比較

| 観点 | Option 1: HookAware | Option 2: Pool | Option 3: Composite |
|------|---------------------|----------------|---------------------|
| 既存コードとの互換性 | △ | ✗ | ✅ |
| 循環依存リスク | ✗ | ○ | ✅ |
| 実装の複雑さ | △ | ✗ | ○ |
| テスタビリティ | △ | ○ | ✅ |
| 柔軟性 | △ | ○ | ✅ |
| 段階的導入の可否 | △ | ✗ | ✅ |
| **総合評価** | ❌ | △ | ✅ |

## 実装上の注意点

### 1. connect/disconnect操作

```
複数Redis接続管理の方針:

connect():
  ┌────┐  ┌────┐  ┌────┐
  │ A  │  │ B  │  │ C  │  ← 全てに接続試行
  └─┬──┘  └─┬──┘  └─┬──┘
    ✓       ✗       ✓
    └───────┴───────┘
    少なくとも1つ成功 → true

disconnect():
  全ての接続をクローズ（エラーは無視）

isConnected():
  少なくとも1つ接続中 → true
```

### 2. keys()操作の戦略

```
Failover版:
  Primary優先、失敗時はフォールバック
  [Redis A].keys() → 失敗
  [Redis B].keys() → 成功 (この結果を返す)

MultiWrite版:
  全Redisから取得してマージ
  [Redis A].keys() → [key1, key2]
  [Redis B].keys() → [key2, key3]
  → マージ: [key1, key2, key3] (重複削除)
```

### 3. ログ出力の設計

```
┌─────────────────────────────────┐
│ Composite.setLogger(logger)     │ ← Loggerを設定
└────────┬────────────────────────┘
         │ 伝播
    ┌────┼────┐
    ↓    ↓    ↓
  [A]  [B]  [C]  ← 全子接続にも設定

ログレベルの使い分け:
  info:     Primary以外が使われた場合
  warning:  Fallback成功、一部失敗
  error:    特定接続の失敗
  critical: 全接続失敗
```

### 4. エラーハンドリング方針

```
Failover版:
  ┌────────┐
  │ try A  │ → 失敗 (ログ: error)
  └────────┘
       ↓
  ┌────────┐
  │ try B  │ → 成功 (ログ: warning)
  └────────┘
       ↓
    return OK

MultiWrite版:
  ┌────────┐
  │ try A  │ → 成功
  └────────┘
  ┌────────┐
  │ try B  │ → 失敗 (ログ: error)
  └────────┘
  ┌────────┐
  │ try C  │ → 成功
  └────────┘
       ↓
  requireAllWrites = true  → return false
  requireAllWrites = false → return true
```

## セキュリティ考慮事項

```
┌─────────────────────────────────────────────┐
│ セッションIDのマスキング (必須)             │
├─────────────────────────────────────────────┤
│                                             │
│ ✗ NG: session_id => 'abc123xyz789'         │
│ ✓ OK: session_id => '...x789'              │
│       (末尾4文字のみ表示)                   │
│                                             │
│ 理由: ログ漏洩時のセッションハイジャック    │
│       リスクを最小化                        │
└─────────────────────────────────────────────┘

┌─────────────────────────────────────────────┐
│ 接続情報のログ出力 (注意)                   │
├─────────────────────────────────────────────┤
│                                             │
│ ✓ OK: host, port, database                 │
│ ✗ NG: password, auth情報                   │
│                                             │
│ 複数Redis構成では、どのRedisを使用したか   │
│ の情報は有用だが、認証情報は出力しない      │
└─────────────────────────────────────────────┘
```

## テスト戦略

```
┌──────────────────────────────────────────────────┐
│ ユニットテスト: Compositeクラス単体             │
├──────────────────────────────────────────────────┤
│                                                  │
│ テスト対象: FailoverRedisConnection              │
│ モック使用: RedisConnectionInterface             │
│                                                  │
│ テストケース:                                    │
│  ✓ Primary失敗時にFallbackが使われる            │
│  ✓ 全接続失敗時にfalseを返す                    │
│  ✓ Loggerに適切にログ出力される                 │
│  ✓ 接続・切断が正しく伝播する                   │
└──────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────┐
│ 統合テスト: 実際のRedis/ValKeyを使用            │
├──────────────────────────────────────────────────┤
│                                                  │
│ テスト対象: 実際の複数Redis構成                  │
│ 環境: docker-compose (Redis 2台以上)            │
│                                                  │
│ テストケース:                                    │
│  ✓ MultiWrite: 全Redisに書き込まれる           │
│  ✓ Failover: Primary停止時にFallbackで動作     │
│  ✓ セッションハンドラとの統合                   │
│  ✓ Hook(ReadTimestamp等)との統合                │
└──────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────┐
│ E2Eテスト: 実際のユースケースを検証             │
├──────────────────────────────────────────────────┤
│                                                  │
│ シナリオ1: Primaryダウン時のフォールバック      │
│  1. セッション作成 (Primary正常)                │
│  2. Primaryを停止                               │
│  3. セッション読み込み (Fallbackから成功)       │
│  4. タイムスタンプも記録される (Fallback)       │
│                                                  │
│ シナリオ2: ダブルライト構成での整合性           │
│  1. セッション作成 (両Redisに書込)             │
│  2. 一方のRedisから読み込み                     │
│  3. もう一方のRedisから読み込み                 │
│  4. 両方で同じデータが取得できる                │
└──────────────────────────────────────────────────┘
```

## パフォーマンス考慮事項

```
┌──────────────────────────────────────────────────┐
│ MultiWriteのオーバーヘッド                       │
├──────────────────────────────────────────────────┤
│                                                  │
│ 直列書き込みによるレイテンシ増加:                │
│                                                  │
│  単一Redis:     1ms  ████                        │
│  2台MultiWrite: 2ms  ████████  (2倍)            │
│  3台MultiWrite: 3ms  ████████████  (3倍)        │
│                                                  │
│ 対策案 (将来的な拡張):                           │
│  • 並列書き込み (非同期・マルチプロセス)         │
│  • Write-behindキャッシュパターン                │
└──────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────┐
│ Failoverのレイテンシ                             │
├──────────────────────────────────────────────────┤
│                                                  │
│ Primary正常時:                                   │
│  ┌─────┐                                         │
│  │  A  │ → 1ms  ████                             │
│  └─────┘                                         │
│                                                  │
│ Primary障害時:                                   │
│  ┌─────┐                                         │
│  │  A  │ → タイムアウト (数秒) ████████████      │
│  └─────┘                                         │
│     ↓                                            │
│  ┌─────┐                                         │
│  │  B  │ → 1ms                                   │
│  └─────┘                                         │
│                                                  │
│ 対策案:                                          │
│  • ヘルスチェック機能 (事前に障害検知)           │
│  • Circuit Breakerパターン (高速フェイル)        │
│  • タイムアウト値の調整                          │
└──────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────┐
│ 推奨構成                                         │
├──────────────────────────────────────────────────┤
│                                                  │
│ 読み取り重視:                                    │
│   → FailoverRedisConnection                      │
│       (Primary高速、Fallbackは緊急時のみ)       │
│                                                  │
│ 可用性重視:                                      │
│   → MultiWriteRedisConnection                    │
│       (レイテンシ増加を許容、データ保全優先)    │
│                                                  │
│ バランス型:                                      │
│   → FailoverRedisConnection (読み取り)           │
│   + 非同期レプリケーション (書き込み)            │
└──────────────────────────────────────────────────┘
```

## まとめ

### 推奨設計

```
┌────────────────────────────────────────────────────────┐
│ ✅ CompositeRedisConnection (推奨)                     │
├────────────────────────────────────────────────────────┤
│                                                        │
│ 選定理由:                                              │
│  1. 既存Hookコードを変更不要                           │
│  2. 循環依存のリスクなし                               │
│  3. 段階的に導入可能                                   │
│  4. 柔軟な拡張性 (カスタムComposite実装可能)           │
│  5. テスト・保守が容易                                 │
│                                                        │
│ 効果:                                                  │
│  • Hook内のRedis操作も複数Redis対応                   │
│  • セッションデータとHookデータで統一的な戦略          │
│  • アーキテクチャの一貫性向上                          │
└────────────────────────────────────────────────────────┘
```

### 実装ロードマップ

```
┌─────────────────────────────────────────────────────┐
│ Issue #29は「低優先度」のため、段階的に進める        │
└─────────────────────────────────────────────────────┘

Step 1: 設計レビュー (1-2週間)
  │
  ├─ このドキュメントをチーム/コミュニティでレビュー
  ├─ フィードバック収集
  └─ 設計の最終調整
       ↓
Step 2: PoC実装 (1週間)
  │
  ├─ RedisConnectionInterfaceの定義
  ├─ FailoverRedisConnectionの実装
  └─ 基本的な動作確認
       ↓
Step 3: ドキュメント整備 (数日)
  │
  ├─ 使用例・サンプルコード作成
  ├─ CLAUDE.mdに設計パターン追記
  └─ APIドキュメント生成
       ↓
Step 4: 本実装 (2-3週間)
  │
  ├─ Phase 1: インターフェース導入
  ├─ Phase 2: Composite基底クラス
  ├─ Phase 3: 具象Composite実装
  └─ Phase 4: テスト・検証
       ↓
Step 5: 運用フィードバック (継続的)
  │
  ├─ 実際の使用事例の収集
  ├─ パフォーマンス測定
  └─ 必要に応じて改善
```

### 期待される効果の視覚化

```
Before (現状):
┌────────────────┐
│ セッション     │ → [Redis A] ✓ フォールバック可
│ タイムスタンプ │ → [Redis A] ✗ フォールバック不可
│ カスタムHook   │ → [Redis A] ✗ フォールバック不可
└────────────────┘

After (Composite導入後):
┌────────────────┐      ┌─────────────────┐
│ セッション     │ →─┐  │ Failover        │
│ タイムスタンプ │ →─┼─→│  ├─ Redis A     │
│ カスタムHook   │ →─┘  │  └─ Redis B     │
└────────────────┘      └─────────────────┘
                         ✓ 全て統一的にフォールバック
```

### 次のアクション

```
□ 1. このドキュメントをGitHub Issue #29にリンク
□ 2. レビュー依頼 (@メンテナー宛)
□ 3. フィードバック期間を設定 (例: 2週間)
□ 4. フィードバックを元に設計を最終化
□ 5. 実装着手の判断 (優先度と他タスクとのバランス)
```

---

### 参考資料

- **デザインパターン**
  - [Composite Pattern](https://en.wikipedia.org/wiki/Composite_pattern) - 複数オブジェクトを透過的に扱う
  - [Decorator Pattern](https://en.wikipedia.org/wiki/Decorator_pattern) - 機能を動的に追加

- **Redis高可用性**
  - [Redis Sentinel](https://redis.io/docs/management/sentinel/) - Redis公式のHA機能
  - [Redis Cluster](https://redis.io/docs/reference/cluster-spec/) - Redis公式のクラスタ機能

- **このプロジェクトの関連ドキュメント**
  - `doc/architecture.md` - アーキテクチャ設計書
  - `doc/specification.md` - 機能仕様書
  - `doc/redis-integration.md` - Redis統合仕様
